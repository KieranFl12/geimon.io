<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href='https://fonts.googleapis.com/css?family=Racing Sans One' rel='stylesheet'>
    <link rel="stylesheet" href="style.css">
    <title>Deck Page</title>
    <body style="background-color:rgb(78, 78, 78);">
    <style>
        .card-button {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: transparent;
            border: none;
            cursor: pointer;
            pointer-events: all;
        }
        .card-wrapper button {
            background-color: transparent;
            border: none;
            cursor: pointer;
        }
        .card-wrapper button:focus {
            outline: none;
        }
        .card-wrapper button:hover {
            outline: none;
        }
        .scaled-card, 
        .scaled-card * {
        pointer-events: auto !important;
        user-select: text !important;  /* so you can try selecting text, verifying interaction */
        }
        .main-container {
        display: flex;
        height: 80vh; /* adjust as needed */
        gap: 10px;
        padding: 0 10px 10px 10px;
        }
        /* Left side: existing container */
        .container {
        flex: 1;
        display: flex;
        gap: 10px;
        overflow-y: auto;
        }

        /* Right side: search panel */
        .search-panel {
        width: 320px;
        background-color: #2f2f2f;
        border-radius: 8px;
        display: flex;
        flex-direction: column;
        padding: 12px;
        color: white;
        box-shadow: 0 0 10px black;
        overflow-y: auto;
        }

        .search-panel input[type="search"] {
        padding: 8px 10px;
        font-size: 16px;
        border-radius: 6px;
        border: none;
        margin-bottom: 12px;
        outline: none;
        width: 100%;
        box-sizing: border-box;
        font-family: 'Racing Sans One', cursive;
        }

        .search-results {
        flex: 1;
        overflow-y: auto;
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        justify-content: center;
        }

        /* Make cards in search-results have same style as .card-wrapper children */
        #card-wrapper > div, 
        .search-results > div {
        /* Assuming renderCard puts cards as divs in the container */
        cursor: pointer;
        }
    </style>
</head>
<body>
  <img src="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/try_2.png" class="bg-image" alt="">
    <div>
        <p style="font-size: 200%; text-align:center; font-size: 260%; text-shadow: 2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black;"><game-title>Geimon!</game-title></p>
        <h2 id="deck-name" style="font-size: 200%; color:white; text-align:center; text-shadow: 2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black; margin-top: 16px;"></h2>
    </div>
    <div style="display: flex; flex-direction: row; align-items: center; justify-content: center;">
        <button id="save-deck-btn" class="button buttonEvenSmaller" style="background-color: purple; color: white; padding: 8px 16px; font-family: 'Racing Sans One', cursive; border-radius: 6px; cursor: pointer;">
            Save Deck
        </button>
        <button id="close-deck-btn" class="button buttonEvenSmaller" style="background-color: rgb(187, 0, 0); color: white; padding: 8px 16px; font-family: 'Racing Sans One', cursive; border-radius: 6px; cursor: pointer;">
            Close Deck
        </button>
    </div>

    <div id="deck-info" style="width: 60%; margin: 12px auto; padding: 8px 16px; background-color: #3a3a3a; color: white; font-family: 'Racing Sans One', cursive; font-size: 18px; border-radius: 8px; display: flex; gap: 8px; text-align: center; justify-content: space-between;">
        Loading deck info...
    </div>

    <div class="main-container">
    <div class="container">
      <div class="viewing-window" id="viewing-window">
        <div class="scaled-card" id="scaled-card"></div>
      </div>
        <div class="card-wrapper" id="card-wrapper"></div>
    </div>

    <div class="search-panel" id="search-panel">
        <input type="search" id="search-input" placeholder="Search cards by name... (A-Z)" autocomplete="off" />
        <div class="search-results" id="search-results"></div>
        </div>
    </div>

    <div id="tooltip" class="tooltip"></div>

    <p class="empty-deck-message" id="empty-message" style="display: none;">This deck is currently empty.</p>

    <script type="module">
        import { cards } from "./data/cards.js";
        import { renderCard } from "./utils/cardRenderer.js";
        import { addTooltipListeners } from './utils/cardRenderer.js';

        document.addEventListener("DOMContentLoaded", () => {
            //const sortedCards = cards.sort((a, b) => a.name.localeCompare(b.name));
            //sortedCards.forEach(card => renderCard(card, container));

            const container = document.getElementById("card-wrapper");
            const emptyMessage = document.getElementById("empty-message");
            const deckNameElement = document.getElementById("deck-name");
            const viewingWindow = document.getElementById("viewing-window");
            const scaledCardContainer = document.getElementById("scaled-card");
            let lastHoveredCard = null;

            const searchInput = document.getElementById("search-input");
            const searchResults = document.getElementById("search-results");

            const storedDeckName = localStorage.getItem("selectedDeckName") || "My Deck";
            deckNameElement.textContent = storedDeckName;

            container.innerHTML = "";  // Clear container before rendering

            let storedCards = localStorage.getItem("selectedDeckCards");
            let cardIds = storedCards ? JSON.parse(storedCards) : [];

            const saveDeckBtn = document.getElementById("save-deck-btn");
            const closeDeckBtn = document.getElementById("close-deck-btn");

            // Save Deck button functionality
            saveDeckBtn.addEventListener("click", () => {
            const deckName = localStorage.getItem("selectedDeckName") || "My Deck";
            // Assuming cardIds is your array of card IDs
            fetch("https://geimon-app-833627ba44e0.herokuapp.com/saveDeck", {
                method: "POST",
                headers: {
                "Content-Type": "application/json",
                credentials: 'include'
                },
                body: JSON.stringify({
                deckName: deckName,
                cardIds: cardIds
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                alert("Deck saved successfully!");
                // Also optionally update localStorage
                localStorage.setItem("selectedDeckCards", JSON.stringify(cardIds));
                } else {
                alert("Error saving deck: " + (data.error || "Unknown error"));
                }
            })
            .catch(error => {
                console.error("Error saving deck:", error);
                alert("Error saving deck. Check console for details.");
            });
            });

            // Close Deck button functionality
            closeDeckBtn.addEventListener("click", () => {
            window.close();
            });

            function saveDeck() {
                localStorage.setItem("selectedDeckCards", JSON.stringify(cardIds));
                updateDeckInfo(
                    cardIds
                        .map(id => cards.find(card => String(card.id) === String(id)))
                        .filter(Boolean)
                );
            }

            function renderDeck() {
                container.innerHTML = "";
                if (cardIds.length === 0) {
                    emptyMessage.style.display = "block";
                } else {
                    emptyMessage.style.display = "none";

                    const deckCards = cardIds
                        .map(id => cards.find(card => String(card.id) === String(id)))
                        .filter(Boolean);

                    updateDeckInfo(deckCards);

                    console.log("Deck Card IDs:", cardIds);
                    console.log("Matching cards found:");
                    deckCards.forEach(card => console.log(card));

                    deckCards.forEach(card => {
                    const cardElement = renderCard(card, container);
                    console.log("Attaching event listener to:", cardElement);
                    if (cardElement) {
                        const button = document.createElement("button");
                        button.classList.add("card-button");
                        button.addEventListener("click", () => {
                            const index = cardIds.indexOf(card.id);
                            if (index !== -1) {
                                cardIds.splice(index, 1); // remove the card id
                                saveDeck();
                                renderDeck();
                            }
                        });

                        cardElement.appendChild(button);

                        cardElement.addEventListener("mouseenter", () => {
                            console.log("Mouse entered card:", cardElement);
                            scaledCardContainer.innerHTML = "";
                            const clone = cardElement.cloneNode(true);
                            const cloneButton = clone.querySelector(".card-button");
                                if (cloneButton) {
                                    cloneButton.remove();
                                }
                            clone.classList.add("scaled-card");
                            scaledCardContainer.appendChild(clone);
                            addTooltipListeners(clone);
                            console.log("Checking cloned card keywords:");
                            clone.querySelectorAll(".keyword").forEach((keyword, index) => {
                                console.log(`Keyword ${index + 1}:`, keyword.textContent, "Description:", keyword.dataset.description);
                            });
                            lastHoveredCard = clone;
                        });
                    } else {
                        console.warn("No card element found for card:", card);
                    }
                });

                container.addEventListener("mouseleave", () => {
                    if (lastHoveredCard) {
                        console.log("Mouse left container");
                        lastHoveredCard = null;
                    }
                });
            }
        }

    renderDeck();

    const sortedCards = [...cards].sort((a, b) => a.name.localeCompare(b.name));

    async function updateDeckInfo(deckCards) {
    // Count card types
    const counts = {
        Champions: 0,
        Actions: 0,
        Equipments: 0,
        Obelisks: 0,
        Rush: 0,
        Reflex: 0,
    };

    deckCards.forEach(card => {
        switch (card.type) {
            case 'Champion': counts.Champions++; break;
            case 'Action': counts.Actions++; break;
            case 'Equipment': counts.Equipments++; break;
            case 'Obelisk': counts.Obelisks++; break;
            case 'Rush': counts.Rush++; break;
            case 'Reflex': counts.Reflex++; break;
        }
    });

    const total = deckCards.length;
    const deckInfoDiv = document.getElementById('deck-info');

    // Show loading text while fetching legality
    deckInfoDiv.textContent = "Loading deck info...";

    async function checkLegality(deckName) {
        try {
            const response = await fetch('https://geimon-app-833627ba44e0.herokuapp.com/isLegal', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify({ deck_name: deckName })
            });
            const data = await response.json();
            return data.legal;
        } catch (error) {
            console.warn("Error fetching deck legality status:", error);
            return false;
        }
    }

    const storedDeckName = localStorage.getItem("selectedDeckName") || "My Deck";
    const isLegal = await checkLegality(storedDeckName);
    const deckSizeColor = isLegal ? "#4CAF50" : "#ff4d4d";

    deckInfoDiv.innerHTML = `
        <span style="color: ${deckSizeColor};">Deck Size: ${total}</span>
        <span>Champions: ${counts.Champions}</span>
        <span>Actions: ${counts.Actions}</span>
        <span>Equipments: ${counts.Equipments}</span>
        <span>Obelisks: ${counts.Obelisks}</span>
        <span>Rush: ${counts.Rush}</span>
        <span>Reflex: ${counts.Reflex}</span>
    `;
}

      // Render all cards initially in search results
      function renderSearchResults(filteredCards) {
        searchResults.innerHTML = "";
        filteredCards.forEach(card => {
          const cardElement = renderCard(card, searchResults);
          if (cardElement) {
            const button = document.createElement("button");
            button.classList.add("card-button");
            button.addEventListener("click", () => {
                if (!cardIds.includes(card.id)) {
                    cardIds.push(card.id);
                    saveDeck();
                    renderDeck();
                }
            });
            cardElement.appendChild(button);

            cardElement.addEventListener("mouseenter", () => {
              scaledCardContainer.innerHTML = "";
              const clone = cardElement.cloneNode(true);
              const cloneButton = clone.querySelector(".card-button");
              if (cloneButton) cloneButton.remove();
              clone.classList.add("scaled-card");
              scaledCardContainer.appendChild(clone);
              addTooltipListeners(clone);
              lastHoveredCard = clone;
            });
          }
        });

        if (filteredCards.length === 0) {
          searchResults.innerHTML = `<p style="color:#ccc; text-align:center; width:100%;">No cards found</p>`;
        }
      }

      renderSearchResults(sortedCards);

      searchInput.addEventListener("input", () => {
        const query = searchInput.value.trim().toLowerCase();
        if (query === "") {
          renderSearchResults(sortedCards);
        } else {
          const filtered = sortedCards.filter(card => card.name.toLowerCase().includes(query));
          renderSearchResults(filtered);
        }
      });
    });
    </script>
</body>
</html>
